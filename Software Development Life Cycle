A framework that describes the activities performed at each stage of a software development project.

Its goal is to:
	Produce a high quality product
	Within the schedule
	Within the budget
	
SDLC:
	1. Requirement Analysis
	2. Design
	3. Implementation
	4. Testing
	5. Evolution
Requirement Analysis:

Identifying musts and good to haves
Identifying Quality/Security needs
Identifying project risk

Software Design:

The design is the first step in the actual development of the product 
	High level design - architecture
	Detail design - where you actually write algorithms
Start with the architecture
	Have at least two different architecture
	
Testing:

The process of evaluating the product to make sure it meets the specified requirement

There are different types of testing:
	Execution( manual, automatic, hybrid)
	Methods (static, dynamic)
	Approaches (black box, white box, gray box)
	Levels (when, what)

Evaluation (operation and maintenance)
	
	Product deployment
		Installation
		Training
		Operation
	
	Maintenance
		Big fix
		Adapting functionality
		Adding adaptability
		
SDLC Models:

Almost all models have many common phases ( Design, Implementation, Validation, and Maintenance)
The difference between models is in what order they use these phases

Overall goal is to increase product quality

Iterative Development vs. Incremental Development

Iterative: 
	Take slices of a product and stack them on top of each other
	
Incremental: 
	Putting pieces together, similar to Legos 
	Prioritizes requirements of the system and then implements them in groups
	Each subsequent release of the system adds new function to the previous release, until all designed functionality has been implemented.

Pros/Cons:

Pros 
	- Early operational/working product
	- Customer can respond to each build
	- Lowers initial delivery cost
	- Risk of changing requirements is reduced

Cons 
	- Requires good planning and design
	- Early definition of fully functional system
	- Well-defined module interfaces
	- Costs higher than Waterfall

Waterfall Model - the very first SDLC
	
	Pros:
		- Easy to understand
		- Provides structure
		- Milestones are well understood
		- Identified deliverables, documentation and milestones at the end of each phase
	Cons 
		- Requirements must be stable
		- Inhibit flexibility
		- False impression of progress
	
V-Shaped SDLC Model - a variant of the Waterfall 
	
	Testing of the product is planned in parallel with a corresponding phase of development
	
	Pros
		- All Waterfall advantages
		- Quality assurance starts on the first day
	
	Cons
		- All Waterfall disadvantages
	
Spiral SDLC Model:

	- Combination of waterfall and prototyping with the addition of risk analysis
	- Each cycle involves the same sequence of steps as the waterfall process model

Pros:
	- Early indication of challenging risks
	- Critical high-risk functions are developed first
	- Early and frequent feedback from users
 Cons:
	- Time spent for evaluating risks
	- Risk assessment expertise required
	- Time spent planning and resetting objectives
	- Developers need to be reassigned during non-development times

Unified Process:

	Inception - define the scope of the project and develop the business case
	Elaboration - plan project, specify features, and baseline the architecture (to focus development effort)
	Construction - build the product in increments
	Transition - transition the product to its users
	
Agile Process: both incremental and iterative

	- Speed up or bypass one or more life cycle phases
	- Usually less formal and reduced scope
	- Used for time-critical applications
	- Used in organizations that employ disciplined methods
ASD - Adaptive Software Development
FDD - Feature Driven Development
Crystal Clear
DSDM - Dynamic Software Development Method
RAD - Rapid Application Development
XP - Extreme Programming
RUP - Rational Unify Process
SCRUM - (more to come)

Software Process Models and Standards:

	CMM - capability maturity model
		PSP - personal software process
		TSP - team software process
	ISO 9000
	SPICE - Software Process Improvement and Capability dEtermination
	
Software Capability Maturity Model
	1. Initial 
	2. Repeatable
	3. Defined
	4. Managed
	5. Optimizing

